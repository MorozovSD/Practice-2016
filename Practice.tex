\documentclass{article}

%Вставки кода
\usepackage{listings} 

%добавляет русский язык
\usepackage[english,russian]{babel}
\usepackage[14pt]{extsizes}
%Рисунки
\usepackage[dvips]{graphicx}
%Каталоги для рисунков
\graphicspath{{./image-parallel/}{image-git/}{image-practice-part/}}
%Пакет работы с цветом
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{myorange}{rgb}{1,0.5,0.25}
%Пакет работы с гиперссылками и установка цвета ссылок
\usepackage[colorlinks,linkcolor=blue,urlcolor=blue]{hyperref}
%Отступы
\usepackage[left=3cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
%Добавление абзацев после оглавления (indentfirst)
\usepackage[indentfirst]{titlesec}
\usepackage{titletoc}
%%TODO Настроить нумерацию
\usepackage[utf8]{inputenc}
\linespread{1.3}
%Для таблиц
\usepackage{multirow}
\author{Морозов С.Д.}
\begin{document}

%Настройка параметров вставок кода

\lstset{ 
	language=C,                 % выбор языка для подсветки (здесь это С)
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	keywordstyle=\color{blue},	
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)},   % если нужно добавить комментарии в коде
	numberstyle=\tiny\color{mygray},
  	rulecolor=\color{black},
  	stringstyle=\color{myorange},
  	commentstyle=\color{mygreen},
}


\begin{titlepage}
	\centering
	{\LARGE Университет ИТМО \par}
	\vspace{5mm}
	{\Large Кафедра вычислительной техники\par}
	\vspace{1.5cm}
	{\huge\bfseries Отчет по прохождению практики\par}
	\vspace{3cm}
	\begin{flushleft}
		\hangindent=10cm
		\hangafter=-5
		\noindent 
		{\Large Студента\\
				P3311 группы \\
				Морозова С.Д.\\
				Руководитель \\
				Соснин В.В.
		}
	\end{flushleft}
	\vfill
% Bottom of the page
	\vspace{1cm}
	{\large Санкт-Петербург \par}
	{\large 2016  \par}
\end{titlepage}
%Нужны ли в содержании subsubsection'ы?
	\setcounter{tocdepth}{3}	
	\tableofcontents
	\newpage
	\section{Введение}
	\indent 
	%%Тема паралельные вычисления. Перед тем как приступить к тебе необходимо разобраться с латех и гит...
		Тема прохождения практики "--- параллельные вычисления. Цель задания "--- сравнить различные функции в языке С, которые 		можно использовать для измерения времени работы параллельных программ.
		
		Однако требования руководителя практики таковы, что перед тем как приступить к выполнению основного задания нужно 				ознакомиться с системой компьютерной вёрстки \TeX (\LaTeX), которая должна
	использоваться для написания отчёта, и ознакомиться с системой контроля версий Git, с последующим созданием учетной записи на 	сайте GitHub или анагичном.
	\newpage
	\section{Система компьютерной верстки \TeX(\LaTeX)}	
		\subsection{Краткое описание}
			\TeX ~"--- система компьютерной вёрстки с формулами, разработанная американским профессором информатики Дональдом 				Кнутом. Название происходит от греческого слова $\tau\varepsilon\chi\upsilon\eta$ "--- "<искусство">, "<мастерство">, 				поэтому	последняя буква читается как русская Х. Хотя TeX является системой набора и верстки, развитые возможности 					макроязыка TeX делают его Тьюринг-полным языком программирования. 
		
			\TeX ~работает с боксами (box) и клеем (glue). Бокс "--- двумерный объект прямоугольной формы, характеризуется тремя 
		величинами (высота, ширина, глубина). Элементарные боксы "--- это буквы, которые объединяются в боксы-слова, которые в 				свою очередь сливаются в боксы-строчки, боксы-абзацы и т.д.

        	Между боксами располагается клей, который имеет некоторую ширину по умолчанию и степени увеличения/уменьшения этой 				ширины. Объединяясь в бокс более высокого порядка, боксы могут шевелиться, но после того как найдено оптимальное решение, 		это состояние закрепляется, и полученный бокс выступает как единое целое.
        
       		Инетересный факт. На версии 3.0 дизайн был заморожен, поэтому в новых версиях не будет добавления новой 						функциональности, только исправление ошибок. Версия \TeX 'a ассимтотически приближается к числу $\pi$. Это факт говорит о 		том, что последняя версия	3.14159265 (январь 2014) является крайне стабильной и возможны лишь мелькие исправления. 				Дональд Кнут заявил, что последнее обновление (сделанное после его смерти) сменит номер версии на ~$\pi$, и с этого 				момента все ошибки станут особенностями.
        		
			\LaTeX ~"--- созданный Лесли Лэмпортом набор макрорасширений (или макропакет) системы компьютерной вёрстки \TeX, 				который облегчает набор сложных документов. Стоит отметить, что как и любой другой макропакет\footnote{ Так же существуют 		Plain TeX, AMS-TeX, AMS-LaTeX и т.д.} \LaTeX ~не может расширить возможности \TeX ~(все, что можно сделать в одном пакете 		можно сделать и в любом другом). Пакет позволяет автоматизировать многие задачи набора текста и подготовки статей, 					включая набор текста на нескольких языках, нумерацию разделов и формул, размещение иллюстраций и таблиц на странице, 				ведение библиографии и др. Все это делает \LaTeX ~крайне удобным инструментом для написания научных статей, диссертаций и 		т.п..
					
		\subsection{Сравнение \LaTeX ~и MS Word}
			В качестве сравнения "--- перечислим плюсы и минусы \LaTeX ~перед MS Word(а так же всеми его аналогами). \\	
	    Плюсы \LaTeX: 
	    \begin{itemize} 
	    	%\item	Проста работы с любыми математическими формулами
	    	\item	Кроссплатформенность 
	    	%\item	Без особых трудностей можно получить сноски, список литературы,
			%		оглавление, список таблиц, указатель и т. п.
	    	%\item	Имеется несколько стандартных стилей (книга, статья, доклад,
			%		письмо), с помощью которых получаются документы очень высокого
			%		полиграфического качества 
	    	%\item	Гибкая работа с логической структурой текста
	    	\item	Язык международного обмена по математике и физике (большинство     
   					научных издательств принимают тексты в печать  только в этом формате)
    	\end{itemize}
    Минусы \LaTeX:
		\begin{itemize} 
	    	\item	Не является системой типа WYSIWYG
	    				\footnote{What You See Is What You Get(Что видишь, то и получишь). Стоит отметить, что существуют 									дистрибутивы \TeX ~в которых есть попытки реализовать WYSIWYG. Например платный дистрибутив  BaKoMa TeX + 						текстовый редактор  BaKoMa TeX Word.}   
	    	\item	При серьезных отклонениях от стандартных стилей документов требуется
					достаточно сложное программирование	
    	\end{itemize}
    	
    		То есть, выбирая между \LaTeX ~и MS Word, стоит обратить внимание на то,какой текст вы собираетесь печатать, 					насколько нестандартный будет стиль текста, на его примерный объем. В некоторый случаях достаточно использовать MS Word,   		в других "--- использование \LaTeX ~может заметно упростить работу.
		\newpage		
		\subsection{Выбор инструмента редактирования}
			В ходе изучения всех возможных вариантов работа с \LaTeX ~для создания данного отчета, была выбрана программа 						Textmaker
			\footnote{Оффициальный сай Textmaker:~ \href{http://www.xm1math.net/texmaker/}{http://www.xm1math.net/texmaker/}}.\\
			Выбор Textmaker'а обусловлен следующими его особенностями:
			\begin{itemize} 
	    		\item	Автоматическая подсветка синтаксиса
	    		\item	Функция автодополнения команд \LaTeX
	    		\item	Сокрытие блоков кода (Code folding)
	    		\item	Быстрая навигация по структуре документа
	    		\item	Указание на строку с ошибкой, для быстрой отладки
	    		\item	Интегрированный просмотр PDF
			\end{itemize} 
	\newpage
	\section{Системы контроля версий}
		\subsection{Краткое описание}
			Система контроля версий (СКВ) — это система, регистрирующая изменения в одном или нескольких файлах с тем, чтобы в 				дальнейшем была возможность вернуться к определённым старым версиям этих файлов. 
				
			СКВ широко используются при разработке программного обеспечения, для хранения кодов разрабатываемых программ. Однако 			данные системы подходят не только программистам. Художники, которые хотят сохранять каждое изображение/эксиз своей 					работы, писатели пишущие книги или научные статьи, бухгалтеры, которые хранять разные версии отчетов и т.д., все они 				могут использовать СКВ для достижения своих целей.
				
			Иначе говоря СКВ можно применять в любых областях в которых ведётся работа с большим количеством непрерывно 					изменяющихся электронных документов.
		\subsection{Git}
			Git "--- созданная Линусом Торвальдсом, распределенная система контроля версий.
			\subsubsection{Особенности}
			% По большей части взято от сюда -> https://git-scm.com . Позже может быть перепишу своими словами.  
				Одной из основных особенностей Git состоит в способе хранения данных. В принципе, большинство других систем 					хранит 	информацию как список изменений (патчей) для файлов. Эти системы (CVS, Subversion, Perforce, Bazaar и другие) 			относятся к хранимым данным как к набору файлов и изменений, сделанных для каждого из этих файлов во времени, как 					показано на Рис.~\ref{ris:other-scv}
			
			\begin{figure}[h!]
				\center{\includegraphics[width=0.80\linewidth]{other-scv}}
				\caption{Другие системы хранят данные как изменения к базовой версии для каждого файла.}
				\label{ris:other-scv}
			\end{figure}	
			\newpage
				Git не хранит свои данные в таком виде. Вместо этого Git считает хранимые данные набором слепков небольшой 						файловой системы. Каждый раз, когда вы фиксируете текущую версию проекта, Git, по сути, сохраняет слепок того, как 					выглядят все файлы проекта на текущий момент. Ради эффективности, если файл не менялся, Git не сохраняет файл снова, 				а делает ссылку на ранее сохранённый файл. То, как Git подходит к хранению данных, похоже на Рис.~\ref{ris:git}
			
			\begin{figure}[h!]
				\center{\includegraphics[width=0.80\linewidth]{git}}
				\caption{Git хранит данные как слепки состояний проекта во времени.}
				\label{ris:git}
			\end{figure}
			\newpage
				За счет этого, для большинства операций в Git нужны только локальные ресурсы и файлы. Что в свою очередь 						определяет два основных преимущества Git перед остальными СКВ.
			\begin{itemize}
	    		\item	Быстродействие. Поскольку вся история проекта хранится локально у вас на диске, большинство операций 							кажутся практически мгновенными(в отличии от централизованных системам, где практически на каждую операцию 							накладывается сетевая задержка).
	    		\item	Возможность работать(делать коммиты) без доступа к сети или VPN.
			\end{itemize}
			\newpage
			\subsubsection{Основные команды}
			В целом, следующая картинка (Рис.~\ref{ris:git-command}) наглядно демонстрирует основные команды Git, знание которых 			достаточно, чтобы начать им пользоваться.
			
		\begin{figure}[h]
			\center{\includegraphics[width=0.75\linewidth]{git-command}}
			\caption{Основные команды при работе с Git.}
			\label{ris:git-command}
		\end{figure}
		\newpage
		\subsection{GitHub}
			\href{https://github.com/}{GitHub} — крупнейший веб-сервис для хостинга IT-проектов и их совместной разработки. 				Основан на системе контроля	версий Git и разработан на Ruby on Rails и Erlang компанией GitHub, Inc (ранее Logical 					Awesome).
			
			В ходе прохождения практики, на сайте GitHub была создана учетная запись ~\href{https://github.com/MorozovSD}					{MorozovSD}. В данной учетной записи был создан репозиторий ~\href{https://github.com/MorozovSD/Practice-2016}						{Practice-2016} по которому можно легко отследить процесс прохождения практической работы.
	\newpage
	\section{Паралельные вычисления}
		Т.к. практика предполагает не доскональное изучение параллельного программирования, а лишь сравнение функций замера 			времени в программах, работающих на основе парралельных вычислений, то данная глава носит более ознакомительных характер, 			содержащий тот минимум знаний, необходимый для работы с этой области.
		\subsection{Немножко теории}
		%Интуит Академия Microsoft: Параллельные вычисления и многопоточное программирование разделения компьютеров на три 						класса:	
			%Мультипроцессорные вычислительные комплексы - это компьютеры, обладающие множеством процессоров, работающих на общей 			памяти. В этот класс входит большинство продаваемых сегодня на рынке многоядерных компьютеров.

			%Мультикомпьютерные вычислительные комплексы - представляют множество компьютеров, соединенных высокоскоростными 				линиями связи. Каждый компьютер обладает собственной памятью и обменивается сообщениями с другими компьютерами системы 				для передачи данных. 
	
			Мультипрограммирование "--- параллельное выполнение нескольких программ. Мультипрограммирование позволяет уменьшить 			общее время их выполнения.
			
			Под параллельными вычислениями понимается параллельное выполнение одной и той же программы. Параллельные вычисления 			позволяют уменьшить время выполнения одной программы. Чаще всего, хороший последовательный алгоритм не является таковым 			для параллельного выполнения.(а параллельные алгоритмы могут не являться эффективными при работе с одним процессором), 				поэтому одна из задач паралельных вычислений это разработка эффективных алгоритмов, полностью использующие количество 				преподставленных процессоров. 
			
			Т.к. тема практики "--- измерение времени работы пареллельно работаящей программы, то необходимо получить оценку    			времени выполения программы одним процессором $T_1$  для идеализированного случая, когда число процессоров не 						ограничивается "--- $T_\infty$. А так же оценить верхнюю и нижнюю границы времени выполнения конечным число процессоров 			$T_p$\footnote{В отчете будут представленны только конечные формулы, без доказательств}.
						
		Для введенных характеристик очевидно следующее соотношение:

		\begin{equation}
			\label{eq:easy_attetude}
			T_\infty \le T_p \le T_1
		\end{equation}
			
		Для $T_p$ справедлива следующая оценка снизу:
			
		\begin{equation}
			\label{eq:lower_bound}
			T_p \ge \frac{T_1}{p}
		\end{equation}
			
		Для $T_p$ справедлива следующая оценка сверху:
			
		\begin{equation}
			\label{eq:upper_bound}
			T_p \le \frac{T_1}{p} + T_\infty
		\end{equation}
			
		Исходя из вышеперечисленных неравенств, неравенство(\ref{eq:easy_attetude}) может быть заменено более точным:
			
		\begin{equation}
			\label{eq:attetude}
			\frac{T_1}{p} \le T_p \le \frac{T_1}{p} + T_\infty
		\end{equation}
			
		

		На графике это выглядит следующим образом (Рис.~\ref{ris:graph_attetude}):
			
		\begin{figure}[h!]
			\center{\includegraphics[width=1\linewidth]{graph_attetude}}
			\caption{Графическая интерпритация поведения функции $T_p$}
			\label{ris:graph_attetude}
		\end{figure}
						
			Очевидно, что при $p = 1$ графики функций $T_p$ и $\frac{T_1}{p}$ совпадают. Так же происходит совпадение графиков 				$T_p$ и $\frac{T_1}{p}+T_\infty$ при $p\to\infty$.
		\newpage
		\subsection{Характеристики параллельных вычислений}
			\subsubsection{Ускорение}
				Ускорение $S_p(n)$\footnote{Все вводимые характеристики рассматриваются как функции параметра $n$, 								характеризующего сложность решаемой задачи. Обычно $n$ понимается как объем входных данных.} определяют как 						отношение:
				
			\begin{equation}
				\label{eq:acceleration}
				S_p(n) = \frac{T_1(n)}{T_p(n)}
			\end{equation}			
				
				Интерпритировать данную формулу следует как отношение время наилучшего алгоритма, для которого достаточно одного 				процессора, и время наилучшего параллельного алгоритма, который может использовать $p$ имеющихся процессоров.				
				
			\subsubsection{Эффективность}
				Эффективность $E_p(n)$ определяют как отношение:
				
			\begin{equation}
				\label{eq:efficiency}
				E_p(n) = \frac{S_p(n)}{p}
			\end{equation}	

				При оптимальном ускорении\footnote{Оптимальное ускорение достигается когда $T_p = \frac{T_1}{p}$} эффективность 				равна 1. Если же эффективность существенно ниже 1, то часто число процессоров целесообразно уменьшить, используя 					их более эффективно. 
				
			\subsubsection{Упущенная эффективность}
				Мера неиспользованных возможностей "--- упущенной выгоды "--- $U(n)$, определяют следующим образом:
			
			\begin{equation}
				\label{eq:loss_of_efficiency}
				U(n) = \frac{T_p(n)}{T_{p_{opt}}} - 1
			\end{equation}
			
				Оптимальное время, которое можно достичь, используя $p$ процессоров, дается нижней оценкой для $T_p$, 							поэтому получаем:	

			\begin{equation}
				\label{eq:loss_of_efficiency_second}
				U(n) = p\frac{T_p(n)}{T_1} - 1
			\end{equation}
				
				Если для компьютера с $p$ ядрами время решения задачи оптимально и сокращается в $\sim p$ раз в сравнении с 					решением задачи на одноядерном компьютере, то наши потери равны нулю, возможности компьютера полностью используются. 				Если же задача решается за время $T_1$ "--- столь же долго, как на одноядерном компьютере, то потери пропорциональны 				числу неиспользованных ядер.
				
		\subsection{Основные проблемы паралельного программирования}
			\subsubsection{Синхронизация}
				Синхронизация нужна для того, чтобы согласовать обмен информацией между модулями (между параллельно выполняемыми 				множествами операций). Синхронизация может привести к простою процессора, т.к. после достижения точки синхронизации 				он должен ждать, пока другие задания достигнут точки синхронизации. Задержка с подачей в процессор необходимых данных 			ведет к простою процессора и снижению эффективности параллельной обработки
			\subsubsection{Гонка данных}
				Проблема "<гонки данных"> возникает для мультипроцессорных компьютеров с общей памятью. В одни и те же моменты 					времени процессоры могут получать доступ к одним и тем же данным,хранимым в общей памяти, как для чтения, так и для 				записи.
				
				Если с чтением данных проблем не возникает,то одновременная запись двух разных значений в одну и ту же ячейку 					памяти не возможна. Запись всегда идет последовательно, следовательно в памяти останется храниться значение, 						пришедшее последним (причем не известно какое значение каким прийдет). Конкурирование процессоров за запись в одну и 				ту же ячейку памяти и есть "<гонка данных">. 
				
				Один из способов справиться с этой проблемой "--- это закрытие доступа к ресурсу первым пришедшим процессором. 					Остальные процессоры прерывают выполнение и становятся в очередь за обладание ресурсом. Обладатель ресурса спокойно 				выполняет свою работу, а по ее окончании открывает ресурс, с которым теперь начинает работать тот, кто первым стоит в 			очереди.

				%Гонка данных "--- это одна из самых серьезных проблем параллельного программирования, поскольку при некорректно 				организованной блокировке ресурса программа может завершаться с некорректными результатами без возникновения 						исключительных ситуаций.
				
			\subsubsection{Взаимная блокировка (Deadlock)}
				Блокировка "--- хороший механизм решения проблемы "<гонки данных">. Однако блокировка может прервать выполнение 				всей программы, когда наступает ситуация, называемая взаимной блокировкой, клинчем, смертельным объятием или 						deadlock'ом.
				
				В качестве примера рассмотрим простейшую ситуацию, приводящую к возникновению клинча. Пусть есть два конкурента 				$A$ и $B$, претендующие на два ресурса $x$ и $y$. Пусть гонку за ресурс $x$ выиграл $A$ и соответственно закрыл этот 				ресурс для $B$. Гонку за ресурс $y$ выиграл $B$ и закрыл ресурс для $A$. Но $A$, чтобы закончить свою работу нужен 					ресурс $y$, поэтому он стал в очередь, ожидая освобождения ресурса. Симметрично, $B$ находится в очереди, ожидая 					освобождения ресурса $x$. Возникает ситуация вечного ожидания (которое может разрешить только внешнее воздействие), 				когда ни $A$, ни $B$ не могут продолжить свою работу.(Рис.~\ref{ris:deadlock}):
			
			\begin{figure}[h!]
				\center{\includegraphics[width=0.80\linewidth]{deadlock}}
				\caption{Взаимная блокировка (клинч): а) Общий вид. б) На примере перекрестка.}
				\label{ris:deadlock}
			\end{figure}
	\newpage
			%\subsubsection{Проблема мультикомпьютерных комплексов}
	\newpage
	\section{Функции замера времени}
		%Можно подробнее расписать типы данных и добавить tm и _SYSTEMTIME 
		%%Описывание разных функций замера времени
		Эта глава посвещена функциям замера времени языка Си.
		\subsection{Категории функций}	
			Функции работы со временем можно отнести к трем категориям:
			\begin{itemize} 
				\item Функции календарного времени 
				\item Функции для измерения прошедшего времени CPU
				\item Функции для установки будильников и таймеров
					\footnote{Данная категория функций не используется в практической работе, и рассматриваться не будет}
			\end{itemize}
			\subsubsection{Календарное время}
				 Осуществляет для слежения за датами и временем согласно Грегорианскому календарю. Существуют несколько способов 				представления информации даты и времени. Т.к. нас интересует разрешающая способность (точность замеров времени) 					рассмотрим эти способы представления в зависимости от их разрешающей способности.
			\begin{itemize} 
				\item Тип данных time$\_$t "---  компактное представление, обычно дает число секунд, истекающих начиная с 								некоторого основного времени. Разрешающая способность одна секунда
				\item Тип данных struct timeval "--- представление времени с большей точностью. Разрешающая способность до 								микросекунд
					\footnote{На некоторых платформах возможно отслеживание времени только в пределах разрешающей способности 							системного таймера, который в общем случае устанавливается на значение 100 Гц}
				\item Тип данных timespec  "--- представление времени с более большей точностью. Разрешающая способность до 							наносекунд
			\end{itemize}	 
			\subsubsection{Время процессора}
				Процессорное время отлично от фактических часов, тем что оно не включает временя выполнения другого процесса и 					все потраченное время на ожидание ввода-вывода. Процессорное время представляется типом данных clock$\_$t, и дано 					как ряд импульсов времени относительно произвольного базового времени
			\footnote{Для перевода количества импульсов в секунды, количество импульсов неоходимо делить на CLOCKS$\_$PER$\_$SEC 				(число	импульсов времени clock в секунду)}
			, отмечающего начало одиночного вызова программы. 
				
				Важно! В зависимости от архитектуры компьютера и операционной системы способ слежения за процессорным временем 					может быть разным. Общее для внутренних часов процессора то, что разрешающая способность где-то между тысячной и 					милионной долей секунды.
		
		%https://www.opennet.ru/docs/RUS/glibc/glibc-17.html
		\subsection{Функции}
		%clock_getres - узнать разрешающую способность
		В данной главе будут описаны функциии замера времени в операционных системах Windows и Linux. 
		\subsubsection{Кроссплатформенные функции}
			\paragraph{clock}
				$$clock\_t~clock~(void)$$
				
				Функция возвращает прошедшее \underline{процессорное время}. Базовое время произвольно, но не изменяется внутри 				одиночного процесса. Если процессорное время не доступно или не может представляться, clock возвращает значение 					(clock$\_$t) (-1). Т.к. процессорное время считается по разному в разных ОС, результат работы clock меняется в 						зависимости от используемой ОС.
		\newpage			
			\paragraph*{time}
				$$time\_t~time(time\_t~ *~ timeptr)$$
				
				Функция возвращает текущее \underline{календарное значение времени} в секундах. Если аргумент не является нулевым 			указателем, ей передается значение времени типа time$\_$t.
				
				
			\paragraph*{omp$\_$get$\_$wtime}
			$$double~omp\_get\_wtime(void)$$
				
				функция возвращает значение с плавающей запятой двойной точности, эквивалентное истеченному реальному времени в 				секундах с момента, прошедшего от некоторого "времени в прошлом", которое гарантированно не затрагивает 							программа. Время измеряется для каждого потока , никакой гарантии не может быть сделано , что два различных 						потока	измеряют то же самое время и время каждого потока не обязательно быть глобально одинаковым во всех 							потоках, учавствующих в приложении.	
							
			\paragraph*{gmtime}	
			$$struct~tm~*~gmtime(const~time\_t~*~timeptr)$$
			
				Функция преобразует системное время в секундах в дату по Гринвичу. Результат помещается в структуру типа tm и 					функция возвращает указатель на эту структуру.
				
			\paragraph*{localtime}
			$$struct~tm~*~localtime(const~time\_t~*~timeptr)$$
			
				Функция преобразовывает текущее значение времени, передаваемое как аргумент, через указатель timeptr на time$\_t$ 			в структуру tm (местное время). Так же функция возвращает указатель на эту структуру.
			
			\paragraph*{asctime}
			$$char~*~asctime~(const~struct~tm~*~m_time)$$			
			
				Функция преобразует локальное (местное) время представленное в виде структуры типа struct tm, на которую 						указывает аргумент m$\_$time в текстовую строку. Результат преобразования возвращается функцией в виде указатель на 				строку содержащую дату и время. 
			Возвращаемая строка имеет следующий формат:
			\begin{center}
				"<ННН МММ ДД ЧЧ: ММ: СС ГГГГ $\backslash$ n $\backslash$ 0">, где\\
			\end{center}
			ННН "--- это день недели,\\
			МММ "--- месяц,\\
			ДД "--- день,\\
			ЧЧ: ММ: СС "--- время,\\
			ГГГГ "--- год.	
			
			
		\subsubsection{Windows}	
			В ОС Windows многие старые функции CRT имеют безопасные версии (в названии присутствует приставка "$\_$s"). Если 				безопасная функция существует, то старая менее безопасная версия помечена как нерекомендуемая. 
			
			Отличие безопасных функций в том, что они перехватывают ошибки при их возникновении. Они выполняют дополнительные 				проверки на выполнение условий возникновения ошибки, а в случае ошибки вызывают обработчик ошибок. В нашем случае речь 				идет о функциях localtime, ctime и acstime (т.е. их безопасных версиях localtime$\_$s, ctime$\_$s, acstime$\_$s). Отличие 		безопасных аналогов в том, что в параметрах так же указывается ссылка на буффер (ctime$\_$s, acstime$\_$s) или на 					структуру tm (localtime$\_$s), благодаря чему, эти функции могут быть использованы например в параллельном 							программировании (каждая функция может использовать свой буффер, что исключает различные ошибки, которые могут возникнуть 		при работе с одним буффером).
					
			\paragraph*{GetTickCount}
			$$DWORD WINAPI GetTickCount(void);$$
			$$ULONGLONG WINAPI GetTickCount64(void);$$
			
			Функции извлекает число миллисекунд, которые истекли с тех пор как система была запущена. 
			
			Если разница между двумя вызовами в функции GetTickCount составляет более чем 49.7 дней. Эта проблема решена у 					функции GetTickCount64, переполнение которых крайне маловероятно.
			
		\subsubsection{Linux}	
			
			Функции ctime(), asctime(), помещает результат строку в статический буфер , который повторно используется каждый раз, 		когда вы называете ctime() или asctime(). Вызов gmtime() или localtime() может также изменить дату в этом статическом 				буфере. В параллельных вычислениях это может привести к некорректным результатам, поэтому в Linux при работе с данными 				функциями следует использовать аналоги данных функций с суффиксом $\_$r.
			\paragraph*{localtime$\_$r}
			$$struct~tm~*~localime\_r~(const~time\_t~*~s\_time,~struct~tm~*~m\_time);$$
			
				Функция преобразовывает текущее значение времени, передаваемое как аргумент, через указатель timeptr на time$\_t$ 			в структуру tm (местное время), на которую указывает аргумент m$\_$time. Так же функция возвращает указатель на эту 				структуру.	
	\newpage
			\paragraph*{asctime$\_$r}			
			$$char~*~asctime\_r~(const~struct~tm~*~m\_time,~char~*~buf)$$			
			
				Функция преобразует локальное (местное) время представленное в виде структуры типа struct tm, на которую 						указывает аргумент m$\_$time в текстовую строку длинною 26 символов. Результат преобразования помещается в строку, на 			которую указывает аргумент buf. Возвращаемая строка имеет формат аналогичный фортату строки возвращаемый функцией 					asctime.
				
			\paragraph*{ctime$\_$r}				
				$$char~*~ctime\_r(const~time_t~*~clock,~char~*~buf)$$

				Функция эквивалентна последовательному выполнению функций localtime$\_$r() и asctime$\_$r().
			
			\paragraph*{gettimeofday}
			$$int~gettimeofday(struct~timeval~*tv,~struct~timezone~*tz)$$ 
			
				Функция возвращает системное время в виде структуры timeval.
			\paragraph*{clock$\_$gettime}
			$$int~clock\_gettime(clockid\_t~clk\_id,~struct~timespect~*tp)$$
			
				Функция обеспечивает доступ к нескольким видам системных таймеров и имеет наносекундное разрешение. 
			clk$\_$id  "--- задает вид таймера, например:
			\begin{itemize}
				\item CLOCK$\_$THREAD$\_$CPUTIME$\_$ID "---	Таймер процессора работающий с каждым потоком с высокой разрешающей 						способностью		
				\item CLOCK$\_$PROCESS$\_$CPUTIME$\_$ID "---	Таймер процессора работающий с каждым процессом с высокой 								разрешающей способностью
				\item CLOCK$\_$REALTIME "--- Таймер реального времени в масштабе всей системы
			\end{itemize}	

			\subsection{Сравнение функций}			
			
			Для сравнения функций были выбранны следующие критерии:
			\begin{itemize}
				\item Кроссплатформенность. То есть на каких ОС работает данная функция.
				\item Реентабильность и Thread-safery. Потоко-безопасная функция может вызываться одновременно из нескольких 							потоков, даже когда вызовы используют общие данные, потому что все ссылки на общие данные упорядочиваются.
					Реентерабельная функция также может вызываться одновременно из нескольких потоков, но только тогда, когда 							каждый вызов использует свои собственные данные. Т.е. каждая реентабильная функция является thread-safery 							функцией, но не каждая thread-safery функция является реентабильной.
				\item Возвращаемое значение. Данный критерий выбран только для наглядности, указывает какое значение (int, 								double, time$\_$t и т.д.) возращает функция.
				\item Точность. Какова точность (или разрешающая способность) функции.
			\end{itemize}
			
			\begin{table}
			\begin{tabular}{|c|c|c|c|c|} 
			\hline
			\multirow{2}{*}{Функции} & \multicolumn{4}{|c|}{ Критерии оценивания	}\\
			\cline{2-5}
			\qquad & Платформа & Реент. и  		   & Возв. значение & Точность					\\
			\qquad &\qquad     & thread-safery	   & \qquad 		& \qquad					\\
			\hline
			clock				& Кросс. 	 & +/+ & clock$\_$t 	&	$10^{-3} - 10^{-9}$ сек	\\
			time				& Кросс. 	 & +/+ & time$\_$t	 	&	$1$ сек					\\
			gettimeofday		& Linux 	 & +/+ & timeval		&	$10^{-6}$ сек			\\
			clock$\_$gettime	& Linux 	 & +/+ & int			&	$10^{-9}$ сек			\\
			omp$\_$get$\_$wtime	& Кросс. 	 & +/+ & double			&	$10^{-6}$ сек			\\
			GetTickCount		& Windows 	 & +/+ & DWORDW			& 	$10^{-6}$ сек			\\
			gmtime				& Кросс. 	 & -/- & struct tm 		&	$-$						\\
			localtime 			& Кросс. 	 & -/- & struct tm 		&	$-$						\\
			localtime$\_$r		& Linux 	 & +/+ & struct tm 		&	$-$						\\
			localtime$\_$s		& Windows 	 & +/+ & struct tm 		&	$-$						\\
			asctime		 		& Кросс. 	 & -/- & char	 		&	$-$						\\
			asctime$\_$r 		& Linux 	 & +/+ & char	 		&	$-$						\\
			asctime$\_$s 		& Windows 	 & +/+ & char	 		&	$-$						\\
			ctime				& Кросс. 	 & -/- & char 			&	$-$						\\
			ctime$\_$r			& Linux 	 & +/+ & char 			&	$-$						\\
			ctime$\_$s			& Windows 	 & +/+ & char			&	$-$						\\
			\hline
			\end{tabular}		
		\end{table}	
			
	\newpage
	\section{Практическая часть}
		\subsection{Описание эксперементальной программы}
			Эксперименты проводились с программой код которой представлен ниже:
			
			\begin{lstlisting}[label=some-code,caption=Тестовая программа]
			#include <omp.h>
			#include <stdio.h>
			
			double run_parallel_experiment(int amount_of_threads, unsigned int experiment_size) {
    		unsigned int i;
    		double sum_of_squares = 0;
    		omp_set_num_threads(amount_of_threads); 
    		#pragma omp parallel for reduction(+:sum_of_squares)
   			 for (i = 0; i < experiment_size; ++i) {
        		sum_of_squares += i*i;
    		}
   			return sum_of_squares;
			}

			int main() {
    			double result;
    			double t1;
    			double t2;
				//"Start timer"
    			result = run_parallel_experiment(2, 100000000);
				//"Stop timer"
    			printf("result=%e, time_in_milliseconds=%f\n", result, 1000*(t2 - t1));
    
    			return 0;
			}
		\end{lstlisting}
		\newpage
		
			С ходе экспериментов в строки №19 и 21 подставлялись различные функции замера времени, что в свою очередь сказывалось 		на выводе программы\footnote{Вывод программы есть ни что иное как время выполнение программы, по крайней мере мы 					хотим, чтобы это было временем выполнения.}.
			
			Для получения более точных и достоверных результатов были предприняты следующие шаги:
			
			\begin{itemize}
				\item Было отключено большинство работающих программ, процессов.
				\item Запуск программы осуществлялся несколько раз, с последующим определением среднего значения и 								доверительного интервала 
			\end{itemize}
			
			Работы с Linux была осуществленна через программу Oracle VM VirtualBox, запущенной со следующими характеристиками 				(Рис.~\ref{ris:VirtualBox_parametrs}):

		\begin{figure}[h!]
			\center{\includegraphics[width=1\linewidth]{VirtualBox_parametrs}}
			\caption{Характеристики виртуальной машины.}
			\label{ris:VirtualBox_parametrs}
		\end{figure}
		\newpage
			Так же в качестве дополнительного задания, которое заключается в изучении изменения эффективности работы параллельных 		программ на виртуальной машине в зависимости от количеста отведенных им процессоров, изменялось количество процессоров 				предоставляемых виртуальной машине:

		\begin{figure}[h!]
			\center{\includegraphics[width=1\linewidth]{VirtualBox_processors}}
			\label{ris:VirtualBox_processors}
		\end{figure}
		
		\newpage
					
		\subsection{Результаты работы программы}

		\begin{table}[h!]
		\caption{Windows}
			\begin{tabular}{|c|c|c|c|c|}
			\hline			
			\multirow{2}{*}{Функции} & \multicolumn{4}{|c|}{ Кол-во ядер }\\
			\cline{2-5}
			\qquad 	&  1 & 2  &  3 &  4  \\
			\cline{2-5}
			\hline			
			clock		&32.641$\pm$0.032	& 16.445$\pm$0.024	&	11.226$\pm$0.0289	&	8.652$\pm$0.043		\\
			\hline
			time	&	32$\pm$0.5	&	16$\pm$0.5 &	11$\pm$0.5	&	8$\pm$0.5		\\
			\hline
			omp$\_$get$\_$wtime	&	32.649$\pm$0.039	&	16.455$\pm$0.023	&	11.227$\pm$0.055	&	8.6175$\pm$0.029\\
			\hline
			GetTickCount	&	32.743$\pm$0.026		&	16.609$\pm$0.047	&	11.242$\pm$0.502	&	8.656$\pm$0.012	\\
			\hline
			\end{tabular}
		\end{table}
		
		\begin{table}[h!]
		\caption{Linux (VirtualBox Ubuntu, 4 процессора) }			
			\begin{tabular}{|c|c|c|c|c|}
			\hline
			\multirow{2}{*}{Функции} & \multicolumn{4}{|c|}{ Кол-во ядер }\\
			\cline{2-5}
			\qquad 	&  1  &  2  &  3  &  4 \\
			\cline{2-5}
			\hline			
			clock	&	12.35767 	&	13.690974	&	15.970829 	&	17.1831\\
			&$\pm$0.103098&$\pm$0.852372&$\pm$0.60532&$\pm$0.37756\\			
			\hline
			time	&	12$\pm$0.5	&	7$\pm$0.5	&	6$\pm$0.5	&	5$\pm$0.5		\\
			\hline
			omp$\_$get$\_$wtime	&	12.441215	&	7.256746  &	6.124574 &	5.771348\\
			&$\pm$0.216493&$\pm$0.370947&$\pm$0.27953&$\pm$0.1799238\\
			\hline
			gettimeofday	&	12.580472	&	7.075927	&	5.939196	&	5.709618	\\
			&$\pm$0.382535&$\pm$0.2374386&$\pm$0.291476&$\pm$0.275306\\
			\hline
			clock$\_$gettime	&	12.459468792	&	7.35941419	&	6.078799968	& 5.674500551		\\
								&	$\pm$0.262119073&	$\pm$0.537213588&$\pm$0.251583524&$\pm$0.116543728	\\
			\hline
			\end{tabular}		
		\end{table}
		\newpage
		Для наглядности, полученные данные можно представить в виде графиков (Рис.~\ref{ris:Windows_Linux}):

		\begin{figure}[h]
			\center{\includegraphics[width=1.1\linewidth]{Windows_Linux}}
			\caption{График скорости выполнения программы.}
			\label{ris:Windows_Linux}
		\end{figure}
		\newpage
				
		\subsection{Дополнительное задание}		
		
			Как было сказанно ранее в дополнительном задание будет измерятся зависимость времени выполнения программы на 					виртуальной	машине в зависимости от количества процессоров, предоставленных ВМ и программе. В качестве функции замера 				времени была выбрана функция omp$\_$get$\_$wtime.
			
		\begin{table}[h!]
			\begin{tabular}{|c|c|c|c|c|}
			\hline
			Кол-во процессоров 	& \multicolumn{4}{|c|}{Кол-во процессоров} 										\\
			предоставленные ВМ 	& \multicolumn{4}{|c|}{предоставленные программе}								\\
			\cline{2-5}
								&		1			& 		2			&		3			&		4			\\
			\hline	
			\multirow{2}{*}{4} 	&	12.656385 		&	7.035231		&	6.180582		&	5.601754		\\
								&	$\pm$0.403936 	&  $\pm$0.273854	& $\pm$0.563768 	&$\pm$0.176031		\\
			\hline
			\multirow{2}{*}{3} 	&	12.743709	 	&	7.285559		&	6.110711		&\multirow{2}{*}{-}	\\
								&	$\pm$0.547703	& 	$\pm$0.24012	&   $\pm$0.36705	&					\\
			\hline			
			\multirow{2}{*}{2} 	&	12.908422		&	7.50501			&\multirow{2}{*}{-}	&\multirow{2}{*}{-}	\\
								&   $\pm$0.490109	& $\pm$0.196944		&					&					\\
			\hline					
			\multirow{2}{*}{1} 	&	13.971584		&\multirow{2}{*}{-}	&\multirow{2}{*}{-}	&\multirow{2}{*}{-}	\\					
								&   $\pm$0.090051	&					&					&					\\
			\hline				
			\end{tabular}		
		\end{table}	
	\newpage			
			
			На графике это выгллядит следующим образом (Рис.~\ref{ris:Dop}):

		\begin{figure}[h!]
			\center{\includegraphics[width=0.9\linewidth]{Dop}}
			\caption{График скорости выполнения программы.}
			\label{ris:Dop}
		\end{figure}		
		
		\section{Выводы}
		\subsection{Вывод по основной части практического задания}
				На основе полученных результатов можно сделать следующие выводы:
			\begin{itemize}
				\item Lля работы с параллельными вычислениями не стоит использовать функцию time, всвязи с её малой 							точностью.
				\item В ОС Windows для работы с параллельными вычислениями следует использовать безопасные версии функций(если 					есть, суффикс $\_s$, вместо их устаревших версий.
				\item В Linux для работы с параллельными вычислениями не стоит использовать функцию clock (в качестве фунции 					рамера времени выполнения программы), т.к. в данной ОС она подсчитывает процессорное время, которое в случае с 						параллельными вычеслениями не является реальным временем выполнения программы (в ОС Windows данная так же считает 					процессорное время, но результаты работы этой функции, как получилось в эксперименте, соответствуют реальному времени 			выполнения программы. Вероятно, это обусловленно разными способами расчета процессорного премени). Так же следует 					использовать вместо функций ctime(), asctime() localtime(), их аналоги localtime$\_$r, ctime$\_$r, acstime$\_$r.
				\item Функция clock$\_$gettime обладает наибольшей точностью, а благодаря тому, что первый параметром передается 				ID таймера, данная функция имеет очень большую область применения. Единственный её минус, который мне удалось найти, 				в том, что она не является 	кроссплатформенной (работает только в Linux).	
				\item Из всех расмотренных функций, функция omp$\_$get$\_$wtime является наиболее оптимальной т.к. является 					кросплатформенной, реентабильной и обладает хорошей точностью.
			\end{itemize}
			
				Стоит отметить тот факт, что программа, время выполнения который рамерялось, была довольно простой. Возможно, в 				программах с более сложной структурой, некоторые из функций начали давать неккоректные результаты. Но сложные 						программы в практической работе не рассчатривались ввиду их сложности.
				
				Так же можно заметить, что время выполнения программы в Linux в ~2.5 раза быстрее времени выполнения той же 					программы в Windows. Причины разницы выполнения описаны не будут, т.к. это не является частью данной практической 					работы, и требуют отдельного рассмотрения.
		\subsection{Вывод по дополнительной части практического задания}
				На поддержания виртуальной машины тратится определенное количество ресурсов компьютера. VirtualBox советует 					отдавать виртуальной машине более двух процессоров(как показано на Рис.~\ref{ris:VirtualBox_processors}). 							Эксперементально было проверено, что при увеличении количества процессоров у ВМ, время выполения программы немного 					уменьшается, это обусловлено распределением нагрузки между процессорами на поддержание витруальной машины. Однако при 			предоставлении отдельной программе более  двух процессоров (при предоставлении двух, время выполнения программы 					сокращается примерно в 2 раза), итоговое время выполнения программы изменяется не линейно, а на небольшую величину, 				это связано с тем, что процессоры и без того загруженны (поддерживают виртуальную машину), и не в состоянии 						предоставить все свои возможности данной программе. 
	\newpage
		\subsection{Вывод по производственной практике}
			В ходе прохождения зимней практики была изучена система компьютерной верстки ~\LaTeX, система контроля версий Git (а 			вместе с ней и GitHub). Были получены общие представления о параллельных вычислениях, а так же было рассмотренно 					множество функций замеров времени с поледующим их сравнением. 
		
			Знания, полученные в ходе прохождения, считаю полезными, т.к.:
		\begin{itemize}
			\item ~\LaTeX~ является хорошим инструментом для написания диплома на 4 курсе, а так же для написания научных 						работ, диссертаций.  
			\item Знание Git (или другой системы контроля версий) крайне полезно для любого программиста. Т.к. упрощает 						написание и работу с программами.
			\item Знание функций замера времени, а так же их точность и т.д. позволит лучшем образом их использовать.
			\item Знание (или знакомство) с параллельными вычислениями пригодится в дальнейшем (магистратура/работа), т.к. 						данная дисциплина крайне востребованна в наше время.
		\end{itemize}
	
\end{document}
